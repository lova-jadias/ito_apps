-- ================================================================
-- MIGRATION GOJIKA : Notes & Évaluations
-- ================================================================

-- Amélioration de la table notes existante
ALTER TABLE public.notes
  ADD COLUMN IF NOT EXISTS categorie_examen_id BIGINT REFERENCES public.categories_examens(id),
  ADD COLUMN IF NOT EXISTS semestre_id BIGINT REFERENCES public.semestres(id),
  ADD COLUMN IF NOT EXISTS approuve_par_rp BOOLEAN DEFAULT false,
  ADD COLUMN IF NOT EXISTS approuve_le TIMESTAMPTZ;

COMMENT ON TABLE public.notes IS 'Notes des étudiants avec validation RP (GOJIKA)';

-- Fonction : Calculer la moyenne générale d'un étudiant
CREATE OR REPLACE FUNCTION public.calculer_moyenne_etudiant(
  p_etudiant_id BIGINT,
  p_semestre_id BIGINT DEFAULT NULL,
  p_categorie_id BIGINT DEFAULT NULL
)
RETURNS NUMERIC
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
  v_moyenne NUMERIC;
BEGIN
  SELECT
    SUM(n.note * COALESCE(n.coefficient, ms.coefficient, 1.0)) /
    SUM(COALESCE(n.coefficient, ms.coefficient, 1.0))
  INTO v_moyenne
  FROM public.notes n
  LEFT JOIN public.matieres_semestre ms ON n.matiere_id = ms.matiere_id AND n.semestre_id = ms.semestre_id
  WHERE n.etudiant_id = p_etudiant_id
    AND (p_semestre_id IS NULL OR n.semestre_id = p_semestre_id)
    AND (p_categorie_id IS NULL OR n.categorie_examen_id = p_categorie_id)
    AND n.approuve_par_rp = true;

  RETURN COALESCE(v_moyenne, 0);
END;
$$;

GRANT EXECUTE ON FUNCTION public.calculer_moyenne_etudiant(BIGINT, BIGINT, BIGINT) TO authenticated;

-- Fonction : Obtenir les statistiques d'un groupe
CREATE OR REPLACE FUNCTION public.stats_groupe(
  p_groupe TEXT,
  p_semestre_id BIGINT DEFAULT NULL
)
RETURNS TABLE(
  moyenne_groupe NUMERIC,
  nb_etudiants INT,
  meilleure_moyenne NUMERIC,
  pire_moyenne NUMERIC
)
LANGUAGE plpgsql
STABLE
AS $$
BEGIN
  RETURN QUERY
  SELECT
    AVG(public.calculer_moyenne_etudiant(e.id, p_semestre_id)) AS moyenne_groupe,
    COUNT(e.id)::INT AS nb_etudiants,
    MAX(public.calculer_moyenne_etudiant(e.id, p_semestre_id)) AS meilleure_moyenne,
    MIN(public.calculer_moyenne_etudiant(e.id, p_semestre_id)) AS pire_moyenne
  FROM public.etudiants e
  WHERE e.groupe = p_groupe AND e.statut = 'Actif';
END;
$$;

GRANT EXECUTE ON FUNCTION public.stats_groupe(TEXT, BIGINT) TO authenticated;

-- RLS pour notes (mise à jour)
DROP POLICY IF EXISTS "Les étudiants voient leurs notes" ON public.notes;
DROP POLICY IF EXISTS "Les parents voient les notes de leurs enfants" ON public.notes;
DROP POLICY IF EXISTS "RP/Enseignants peuvent saisir" ON public.notes;

CREATE POLICY "Lecture selon rôle" ON public.notes FOR SELECT USING (
  get_my_role() IN ('admin', 'rp', 'enseignant') OR
  etudiant_id = get_my_student_id() OR
  etudiant_id IN (SELECT get_my_children_ids())
);

CREATE POLICY "RP/Enseignant peuvent saisir" ON public.notes FOR INSERT WITH CHECK (
  get_my_role() IN ('admin', 'rp', 'enseignant')
);

CREATE POLICY "RP/Enseignant peuvent modifier" ON public.notes FOR UPDATE USING (
  get_my_role() IN ('admin', 'rp', 'enseignant')
);

-- Table : Orientations personnalisées (pour futur module)
CREATE TABLE public.orientations (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  etudiant_id BIGINT NOT NULL REFERENCES public.etudiants(id) ON DELETE CASCADE,
  message TEXT NOT NULL,
  type_orientation TEXT, -- 'conseil', 'alerte', 'felicitation'
  genere_le TIMESTAMPTZ DEFAULT now(),
  lu_le TIMESTAMPTZ
);

COMMENT ON TABLE public.orientations IS 'Recommandations personnalisées pour étudiants (module futur)';

ALTER TABLE public.orientations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Étudiant voit ses orientations" ON public.orientations FOR SELECT USING (
  etudiant_id = get_my_student_id()
);

CREATE POLICY "RP/Admin peuvent créer" ON public.orientations FOR INSERT WITH CHECK (
  get_my_role() IN ('admin', 'rp')
);